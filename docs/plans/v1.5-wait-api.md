# Vibium: Wait API Design

## Insight

The eight `waitFor*` methods are two different operations sharing a name:

**"Expect"** — subscribe to an event, do the thing that causes it, get the result.
Must be set up *before* the action.

**"Wait until"** — poll a condition that's already in progress.
Called *after* the cause, or when you need to block on state.

Splitting them makes ordering bugs impossible and the code self-documenting.

---

## API

### `page.expect.*` — before the action

JS:
```js
// callback style (primary)
const res = await page.expect.response("**/api/data", async () => {
  await el.click();
});
console.log(res.status);

// promise style (escape hatch)
const resPromise = page.expect.response("**/api/data");
await el.click();
const res = await resPromise;
```

Python:
```python
# context manager (primary)
async with page.expect.response("**/api/data") as res:
    await el.click()
print(res.value)
```

Sync versions are identical, minus `async`/`await`.

#### Methods

| Method                | Resolves with   |
|-----------------------|-----------------|
| `expect.response(pat, fn?)` | Response  |
| `expect.request(pat, fn?)`  | Request   |
| `expect.navigation(fn?)`    | URL       |
| `expect.event(name, fn?)`   | Event data|
| `expect.download(fn?)`      | Download  |
| `expect.dialog(fn?)`        | Dialog    |

Matchers: glob (`"**/api/users"`), regex (`/\/api\/\d+/`), or predicate (`res => res.status === 200`).

All accept `{ timeout }` as final arg.

---

### `page.waitUntil.*` — after the cause

JS:
```js
await page.waitUntil.url("**/dashboard");
await page.waitUntil.loaded();                    // default: "load"
await page.waitUntil.loaded("networkidle");
await page.waitUntil(() => page.eval("items.length > 5"));
```

Python:
```python
await page.wait_until.url("**/dashboard")
await page.wait_until.loaded("networkidle")
await page.wait_until(lambda: page.eval("items.length > 5"))
```

| Method              | Condition                   |
|---------------------|-----------------------------|
| `waitUntil.url(pat)` | Current URL matches        |
| `waitUntil.loaded(state?)` | Page load state reached (`"load"`, `"domcontentloaded"`, `"networkidle"`) |
| `waitUntil(fn)`     | fn returns truthy           |

Resolves immediately if condition is already true. All accept `{ timeout }`.

---

### `element.waitUntil(state)` — element condition

```js
await spinner.waitUntil("hidden");
await button.waitUntil("enabled");
```

States: `"visible"`, `"hidden"`, `"attached"`, `"detached"`, `"enabled"`, `"disabled"`

Rarely needed — `element.click()` and `element.type()` auto-wait for actionability.
Main use case: waiting for something to *disappear*.

---

### Absorbed into existing methods

`waitFor(selector)` → `page.find(selector)`, which already auto-waits.

`waitForLoad(state)` → option on `page.go()` for the common case:

```js
await page.go("https://example.com", { waitUntil: "networkidle" });
```

`waitUntil.loaded()` still available when the load isn't tied to a navigation.

---

## Migration

| Old                         | New                                      |
|-----------------------------|------------------------------------------|
| `page.waitForResponse(pat)` | `page.expect.response(pat, fn)`          |
| `page.waitForRequest(pat)`  | `page.expect.request(pat, fn)`           |
| `page.waitForEvent(name)`   | `page.expect.event(name, fn)`            |
| `page.waitForURL(pat)`      | `page.waitUntil.url(pat)`                |
| `page.waitForLoad(state?)`  | `page.go(url, { waitUntil })` or `page.waitUntil.loaded(state)` |
| `page.waitFor(selector)`    | `page.find(selector)`                    |
| `page.waitForFunction(fn)`  | `page.waitUntil(fn)`                     |
| `element.waitFor({state})`  | `element.waitUntil(state)`               |

---

## Edge Cases

**Multiple events from one action:**

```js
const [url, res] = await Promise.all([
  page.expect.navigation(),
  page.expect.response("**/api/data"),
  el.click(),
]);
```

```python
async with page.expect.navigation() as nav:
    async with page.expect.response("**/api/data") as res:
        await el.click()
```

**Event already happened:** `expect.*` will timeout — by design, surfaces ordering bugs. `waitUntil.*` checks current state first and resolves immediately if already true.

**Browser lifecycle with `using`:**

```js
await using bro = browser.launch();
const page = bro.page();
// ...
// bro.quit() on scope exit
```

`using`/`await using` fits lifecycle cleanup (browser, session). Don't use it for `expect` — the value goes out of scope with the block.
