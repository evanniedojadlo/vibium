# Vibium: Implementation Plan

**Based on:** Doc #1 (docs/reference/vibium-doc1-playwright-parity.md)
**Principle:** Fat engine, thin clients. All logic in the Go clicker binary. Language clients are thin proxies.

Give Claude Code one phase at a time. Run the checkpoint tests before moving on. If a checkpoint fails, debug before proceeding. Human reviews at ⚠️ markers.

---

## How to use this plan

At the start of each Claude Code session:

> Read docs/reference/vibium-doc1-playwright-parity.md. This is **Phase N**. Here's the scope: [paste phase section]

---

## Group A: Go Engine + JS Async Client

Every command gets built in the Go clicker engine first, then exposed through the JS async client. Phases 1–7.

---

### Phase 1 — Navigation + Pages & Contexts

#### Milestone 1.1: Navigation commands in Go engine

Build command handlers for the 9 navigation commands.

- `page.go(url)` — BiDi: `browsingContext.navigate`
- `page.back()` — BiDi: `browsingContext.traverseHistory(-1)`
- `page.forward()` — BiDi: `browsingContext.traverseHistory(1)`
- `page.reload()` — BiDi: `browsingContext.reload`
- `page.url()` — Client-side: tracked from navigate responses
- `page.title()` — JS: `document.title` via `script.evaluate`
- `page.content()` — JS: `document.documentElement.outerHTML`
- `page.waitForURL(pattern)` — BiDi: poll `browsingContext.navigate` events
- `page.waitForLoad(state?)` — BiDi: `browsingContext.load` / `DOMContentLoaded` events

#### Milestone 1.2: Page & Context lifecycle in Go engine

Build command handlers for the 10 page/context commands.

- `browser.page()` — BiDi: `browsingContext.getTree` (returns first/default page)
- `browser.newPage()` — BiDi: `browsingContext.create` (default context)
- `browser.newContext()` — BiDi: `browser.createUserContext`
- `context.newPage()` — BiDi: `browsingContext.create` (in user context)
- `browser.pages()` — BiDi: `browsingContext.getTree`
- `context.close()` — BiDi: close all pages in context
- `browser.close()` — BiDi: close all contexts + end
- `browser.onPage(fn)` — BiDi: `browsingContext.contextCreated`
- `browser.onPopup(fn)` — BiDi: `browsingContext.contextCreated` (opener)
- `page.bringToFront()` — BiDi: `browsingContext.activate`
- `page.close()` — BiDi: `browsingContext.close`

#### Milestone 1.3: JS async client wiring

Wire up all 19 commands as `async` methods. `browser.launch()` starts the Go binary, connects, returns a `Browser` instance. `browser.newPage()` returns a `Page` instance.

#### Checkpoint:

```javascript
import { browser } from 'vibium'

const bro = await browser.launch()
const vibe = await bro.newPage()
await vibe.go('https://example.com')
console.log(await vibe.url())     // → 'https://example.com/'
console.log(await vibe.title())   // → 'Example Domain'
await vibe.back()
await vibe.forward()
await vibe.reload()

// Multi-page
const vibe2 = await bro.newPage()
await vibe2.go('https://example.com')
console.log((await bro.pages()).length) // → 2

// Contexts
const ctx = await bro.newContext()
const vibe3 = await ctx.newPage()
await vibe3.go('https://example.com')
await ctx.close()

await bro.close()
console.log('Phase 1 ✓')
```

**Commands: 20** | **Running total: 20**

---

### Phase 2 — Element Finding

#### Milestone 2.1: CSS find in Go engine

Build the `find` command handler for CSS selectors.

- `page.find('css')` — BiDi: `browsingContext.locateNodes` (CSS)
- `page.findAll('css')` — BiDi: `browsingContext.locateNodes` (all matches)
- `el.find('css')` — BiDi: scoped `locateNodes`

#### Milestone 2.2: Semantic selector strategies in Go engine

Build strategy routing for structured find options. Each key maps to a strategy.

- `find({role: '...'})` — JS: `computedRole` matching
- `find({text: '...'})` — JS: `innerText` matching
- `find({label: '...'})` — JS: `aria-label` + `<label>` association
- `find({placeholder: '...'})` — JS: `[placeholder]` matching
- `find({alt: '...'})` — JS: `[alt]` attribute matching
- `find({title: '...'})` — JS: `[title]` attribute matching
- `find({testid: '...'})` — BiDi: CSS `[data-testid="..."]`
- `find({xpath: '...'})` — BiDi: `locateNodes` xpath strategy
- `find({near: '...'})` — JS: scope to CSS parent region
- `find({role, text}) combo` — JS: intersect multiple strategies

#### Milestone 2.3: Locator chaining in Go engine

Build chaining and filtering methods on element references.

- `el.first()` — Client-side: index 0
- `el.last()` — Client-side: last index
- `el.nth(index)` — Client-side: index into matches
- `el.count()` — BiDi: `locateNodes` + count
- `el.filter({hasText})` — JS: filter by text content
- `el.filter({has})` — JS: filter by child locator
- `el.or(other)` — Client-side: union of matches
- `el.and(other)` — Client-side: intersection

#### Milestone 2.4: JS async client wiring

`find()` accepts `string | FindOptions`. Returns an `Element` with chaining methods. TypeScript types give full autocomplete for `FindOptions`.

#### Checkpoint:

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()
await vibe.go('https://example.com')

// CSS
const link = await vibe.find('a')
console.log(link)                                 // → Element

// Semantic
const btn = await vibe.find({ role: 'link', text: 'More information' })
console.log(btn)                                  // → Element

// Combo
const combo = await vibe.find({ role: 'link', text: 'More' })
console.log(combo)                                // → Element

// findAll + chaining
const all = await vibe.findAll('p')
console.log(await all.count())                    // → number > 0
const first = all.first()
console.log(first)                                // → Element

// Scoped find
const body = await vibe.find('body')
const nested = await body.find('a')
console.log(nested)                               // → Element

await bro.close()
console.log('Phase 2 ✓')
```

**Commands: 24** | **Running total: 44**

---

### Phase 3 — Element Interaction

#### Milestone 3.1: Core interaction commands in Go engine

Build interaction handlers. The engine handles auto-wait (element must be visible, enabled, stable) and auto-scroll before interaction.

- `el.click()` — BiDi: `input.performActions` (pointer). Auto-scroll, auto-wait.
- `el.dblclick()` — BiDi: `input.performActions` (2x click)
- `el.fill(value)` — BiDi: focus + clear + key actions
- `el.type(text)` — BiDi: `input.performActions` (key sequence). Char by char, no clear.
- `el.press(key)` — BiDi: `input.performActions` (key down+up)
- `el.clear()` — JS: select all + delete
- `el.check()` — JS: click if not already checked
- `el.uncheck()` — JS: click if currently checked
- `el.selectOption(val)` — JS: set `<select>` value, dispatch change
- `el.setFiles(paths)` — JS: FileList manipulation or CDP fallback
- `el.hover()` — BiDi: `input.performActions` (pointer move)
- `el.focus()` — JS: `element.focus()`
- `el.dragTo(target)` — BiDi: `input.performActions` (pointer sequence)
- `el.tap()` — BiDi: `input.performActions` (touch)
- `el.scrollIntoView()` — JS: `element.scrollIntoViewIfNeeded()`
- `el.dispatchEvent(type)` — JS: `element.dispatchEvent(new Event(type))`

#### Milestone 3.2: JS async client wiring

All methods on the `Element` class. Chainable: `await vibe.find({role: 'button', text: 'Submit'}).click()`

#### Checkpoint:

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()

// Login flow on a real site
await vibe.go('https://the-internet.herokuapp.com/login')
await vibe.find('#username').fill('tomsmith')
await vibe.find('#password').fill('SuperSecretPassword!')
await vibe.find({ role: 'button', text: 'Login' }).click()
console.log(await vibe.url())                     // → contains '/secure'

// Checkbox
await vibe.go('https://the-internet.herokuapp.com/checkboxes')
const boxes = await vibe.findAll('input[type="checkbox"]')
const first = boxes.first()
await first.check()

// Hover
await vibe.go('https://the-internet.herokuapp.com/hovers')
await vibe.find('.figure').hover()

await bro.close()
console.log('Phase 3 ✓')
```

**Commands: 16** | **Running total: 60**

---

### ⚠️ Human Review #1

Phases 1–3 cover the core automation loop: navigate, find, interact. Before proceeding, manually verify:

1. `browser.launch()` → `newPage()` → `go()` → `find()` → `click()` works end-to-end
2. `find({role, text})` combo finds the right element
3. `fill()` + `click()` can complete a real login form
4. Contexts provide actual isolation (separate cookie jars)

---

### Phase 4 — Element State + Waiting

#### Milestone 4.1: State-querying commands in Go engine

Almost all JS injection via `script.evaluate`.

- `el.text()` — JS: `element.textContent`
- `el.innerText()` — JS: `element.innerText`
- `el.html()` — JS: `element.innerHTML`
- `el.value()` — JS: `element.value`
- `el.attr(name)` — JS: `element.getAttribute()`
- `el.bounds()` — JS: `element.getBoundingClientRect()`
- `el.isVisible()` — JS: computed style + intersection check
- `el.isHidden()` — JS: inverse of isVisible
- `el.isEnabled()` — JS: `!element.disabled`
- `el.isChecked()` — JS: `element.checked`
- `el.isEditable()` — JS: not disabled, not readonly
- `el.eval(fn)` — BiDi: `script.callFunction` with element ref
- `el.screenshot()` — BiDi: `browsingContext.captureScreenshot` with clip
- `el.waitFor({state})` — BiDi: poll locateNodes + state check

#### Milestone 4.2: Page-level waiting in Go engine

- `page.waitFor(selector)` — BiDi: poll `locateNodes`
- `page.wait(ms)` — Client-side setTimeout
- `page.waitForFunction(fn)` — BiDi: poll `script.evaluate`
- `page.waitForEvent(name)` — BiDi: subscribe + resolve on match
- `page.pause()` — Client-side: debugger breakpoint

#### Checkpoint:

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()
await vibe.go('https://example.com')

const link = await vibe.find('a')
console.log(await link.text())                    // → 'More information...'
console.log(await link.attr('href'))              // → 'https://www.iana.org/...'
console.log(await link.isVisible())               // → true
console.log(await link.isHidden())                // → false
console.log(await link.bounds())                  // → { x, y, width, height }

const h1 = await vibe.find('h1')
console.log(await h1.html())                      // → 'Example Domain'

// Wait for element
await vibe.waitFor('h1')                          // → resolves immediately

// Element screenshot
const buf = await link.screenshot()
console.log(buf.length > 0)                       // → true

await bro.close()
console.log('Phase 4 ✓')
```

**Commands: 19** | **Running total: 79**

---

### Phase 5 — Keyboard, Mouse, Screenshots, Evaluation

#### Milestone 5.1: Keyboard & Mouse in Go engine

All BiDi `input.performActions`.

- `page.keyboard.press(key)` — BiDi: key down+up
- `page.keyboard.down(key)` — BiDi: keyDown
- `page.keyboard.up(key)` — BiDi: keyUp
- `page.keyboard.type(text)` — BiDi: key sequence
- `page.mouse.click(x,y)` — BiDi: pointer click at coordinates
- `page.mouse.move(x,y)` — BiDi: pointerMove
- `page.mouse.down()` — BiDi: pointerDown
- `page.mouse.up()` — BiDi: pointerUp
- `page.mouse.wheel(dx,dy)` — BiDi: scroll
- `page.touch.tap(x,y)` — BiDi: touch tap

#### Milestone 5.2: Screenshots & PDF in Go engine

- `page.screenshot()` — BiDi: `browsingContext.captureScreenshot`
- `page.screenshot({fullPage})` — BiDi: full-page capture
- `page.screenshot({clip})` — BiDi: region capture
- `page.pdf()` — BiDi: `browsingContext.print`

#### Milestone 5.3: Evaluation in Go engine

- `page.eval(expr)` — BiDi: `script.evaluate`
- `page.evalHandle(expr)` — BiDi: `script.evaluate` (return handle)
- `page.addScript(src)` — JS: inject `<script>` tag
- `page.addStyle(src)` — JS: inject `<style>` tag
- `page.expose(name, fn)` — BiDi: `script.addPreloadScript` + callback channel

#### Checkpoint:

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()
await vibe.go('https://example.com')

// Screenshot
const png = await vibe.screenshot()
console.log(png.length > 1000)                    // → true (valid PNG)

const fullPage = await vibe.screenshot({ fullPage: true })
console.log(fullPage.length >= png.length)        // → true

// PDF
const pdf = await vibe.pdf()
console.log(pdf.slice(0, 5).toString())           // → '%PDF-'

// Eval
const title = await vibe.eval('document.title')
console.log(title)                                // → 'Example Domain'

// Keyboard
await vibe.go('https://the-internet.herokuapp.com/inputs')
await vibe.find('input').click()
await vibe.keyboard.type('12345')

// Mouse
await vibe.mouse.click(100, 200)

await bro.close()
console.log('Phase 5 ✓')
```

**Commands: 19** | **Running total: 98**

---

### ⚠️ Human Review #2

Phases 1–5 cover Tier 1 + most of Tier 2. Before proceeding, manually verify:

1. Screenshots produce valid PNGs
2. `keyboard.type()` actually types into input fields
3. `el.text()` / `el.attr()` / `el.isVisible()` return correct values
4. `eval()` can execute arbitrary JS in the page
5. PDF generation works

---

## Group B: Advanced Engine + Remaining Targets

---

### Phase 6 — Network Interception + Dialogs

#### Milestone 6.1: Network interception in Go engine

Network is a major BiDi win — fully native.

- `page.route(pattern, handler)` — BiDi: `network.addIntercept`
- `route.fulfill(response)` — BiDi: `network.provideResponse`
- `route.continue(overrides?)` — BiDi: `network.continueRequest`
- `route.abort(reason?)` — BiDi: `network.failRequest`
- `page.onRequest(fn)` — BiDi: `network.beforeRequestSent`
- `page.onResponse(fn)` — BiDi: `network.responseCompleted`
- `page.setHeaders(headers)` — BiDi: `network.addIntercept` + modify
- `page.waitForRequest(pat)` — BiDi: subscribe + filter
- `page.waitForResponse(pat)` — BiDi: subscribe + filter
- `page.routeWebSocket(pat)` — BiDi: intercept WebSocket frames
- `page.onWebSocket(fn)` — BiDi: WebSocket events

#### Milestone 6.2: Request & Response objects

Lightweight wrappers around BiDi event data.

- `request.url()`, `request.method()`, `request.headers()`, `request.postData()`
  - `request.postData()` uses BiDi `network.addDataCollector` + `network.getData` (data collector set up lazily by `page.route()` / `page.onRequest()`)
- `response.status()`, `response.headers()`, `response.body()`, `response.json()`
- `page.removeAllListeners(event?)` — clears request/response/dialog callbacks; tears down data collector
- `browser.removeAllListeners(event?)` — clears page/popup callbacks

#### Milestone 6.3: Dialogs in Go engine

Fully BiDi.

- `page.onDialog(fn)` — BiDi: `browsingContext.userPromptOpened`
- `dialog.accept(text?)` — BiDi: `browsingContext.handleUserPrompt(accept: true)`
- `dialog.dismiss()` — BiDi: `browsingContext.handleUserPrompt(accept: false)`
- `dialog.message()` — From event data
- `dialog.type()` — From event data

#### Checkpoint:

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()

// Network interception — mock an API
await vibe.route('**/api/**', route => {
  route.fulfill({ status: 200, body: JSON.stringify({ mock: true }) })
})

// Request/Response events
let requestCount = 0
vibe.onRequest(req => { requestCount++ })
await vibe.go('https://example.com')
console.log(requestCount > 0)                     // → true

// Dialog handling
vibe.onDialog(dialog => {
  console.log(dialog.message())                   // → alert text
  dialog.accept()
})
await vibe.eval('alert("hello")')

await bro.close()
console.log('Phase 6 ✓')
```

**Commands: 26** | **Running total: 124**

---

### Phase 7 — Cookies, Frames, Emulation, and All Remaining Categories

#### Milestone 7.1: Cookies & Storage in Go engine

- `context.cookies(urls?)` — BiDi: `storage.getCookies`
- `context.setCookies()` — BiDi: `storage.setCookie`
- `context.clearCookies()` — BiDi: `storage.deleteCookies`
- `context.storageState()` — JS: read localStorage/sessionStorage + cookies
- `context.addInitScript()` — BiDi: `script.addPreloadScript`

#### Milestone 7.2: Frames in Go engine

- `page.frame(nameOrUrl)` — BiDi: `browsingContext.getTree` + filter
- `page.frames()` — BiDi: `browsingContext.getTree`
- `page.mainFrame()` — BiDi: top-level context
- Frames have full Page API — BiDi: frames ARE browsing contexts

#### Milestone 7.3: Emulation in Go engine

- `page.setViewport(size)` — BiDi: `browsingContext.setViewport`
- `page.viewport()` — Client-side
- `page.emulateMedia(opts)` — JS: override `matchMedia`
- `page.setContent(html)` — JS: `document.write()` or navigate to data URL
- `page.setGeolocation()` — JS: override `navigator.geolocation`
- `page.grantPermissions()` — BiDi: `permissions.setPermission`

#### Milestone 7.4: Accessibility in Go engine

- `page.a11yTree()` — JS: walk accessibility tree
- `el.role()` — JS: `element.computedRole`
- `el.label()` — JS: `element.computedLabel`

#### Milestone 7.5: Console, Errors, Workers in Go engine

- `page.onConsole(fn)` — BiDi: `log.entryAdded`
- `page.onError(fn)` — BiDi: `log.entryAdded` (level: error)
- `page.workers()` — BiDi: dedicated worker contexts

#### Milestone 7.6: Downloads & Files in Go engine

- `page.onDownload(fn)` — BiDi: detect navigation to download
- `download.saveAs(path)` — Client-side: file management
- `page.onFileChooser(fn)` — BiDi/JS: detect file input activation

#### Milestone 7.7: Clock in Go engine

- `page.clock.install()` — JS: override `Date`, `setTimeout`, etc.
- `page.clock.fastForward(ms)` — JS: advance mocked timers
- `page.clock.setFixedTime(t)` — JS: freeze clock at time

#### Milestone 7.8: Tracing in Go engine

- `page.tracing.start(opts)` — BiDi: subscribe to events + screenshot stream
- `page.tracing.stop(opts)` — BiDi: end trace, return file

#### Checkpoint:

```javascript
const bro = await browser.launch()

// Cookies
const ctx = await bro.newContext()
const vibe = await ctx.newPage()
await vibe.go('https://example.com')
await ctx.setCookies([{ name: 'test', value: 'val', url: 'https://example.com' }])
const cookies = await ctx.cookies()
console.log(cookies.some(c => c.name === 'test')) // → true
await ctx.clearCookies()

// Viewport
await vibe.setViewport({ width: 375, height: 812 })
const vp = await vibe.viewport()
console.log(vp.width)                             // → 375

// Accessibility
const tree = await vibe.a11yTree()
console.log(tree)                                 // → accessibility tree object

// Console
let logged = false
vibe.onConsole(() => { logged = true })
await vibe.eval('console.log("hi")')
console.log(logged)                               // → true

// Clock
await vibe.clock.install()
await vibe.clock.setFixedTime(new Date('2025-01-01'))
const now = await vibe.eval('new Date().getFullYear()')
console.log(now)                                  // → 2025

await bro.close()
console.log('Phase 7 ✓')
```

**Commands: 30** | **Running total: 154** — all non-AI commands done in engine + JS async.

---

### ⚠️ Human Review #3

The full engine + JS async API is complete. 154 commands. Before fanning out to other targets, manually verify:

1. Network interception can mock API responses
2. Dialogs can be accepted/dismissed
3. Cookies work with context isolation
4. Viewport emulation changes layout
5. Console events fire
6. Run the Phase 1 checkpoint again — regression check

---

### Phase 8 — JS Sync Wrapper

#### Milestone 8.1: Build sync wrapper

Build the sync JS client as a wrapper over the async client. Uses the existing sync mechanism in the codebase.

- `import { browser } from 'vibium/sync'`
- Every async method gets a sync counterpart
- Callback-based methods (`onDialog`, `onConsole`, `route`, etc.) remain callback-based
- TypeScript types mirror the async API exactly
- Same Go engine — no separate implementation

#### Checkpoint:

```javascript
import { browser } from 'vibium/sync'

const bro = browser.launch()
const vibe = bro.newPage()
vibe.go('https://example.com')
console.log(vibe.title())                         // → 'Example Domain'
console.log(vibe.url())                           // → 'https://example.com/'

// Find + interact
vibe.find({ role: 'link' }).click()
console.log(vibe.url())                           // → iana.org URL

// Screenshot
const png = vibe.screenshot()
console.log(png.length > 1000)                    // → true

// Eval
const year = vibe.eval('new Date().getFullYear()')
console.log(typeof year)                          // → 'number'

bro.close()
console.log('Phase 8 ✓')
```

**Commands: 154 (mirror of async)** | All JS targets complete.

---

### Phase 9 — Python Sync + Python Async

#### Milestone 9.1: Python sync client (the default)

- `from vibium import browser` — **this is now sync** (breaking change from current async default)
- snake_case methods: `new_page()`, `find_all()`, `is_visible()`
- kwargs for find: `vibe.find(role='button', text='Submit')`
- Type hints via `FindOptions` TypedDict
- Thin proxy to Go engine — blocks on responses

#### Milestone 9.2: Python async client

- `from vibium.async_api import browser`
- Full `async`/`await` — same methods, same behavior
- Uses asyncio event loop

#### Checkpoint (sync):

```python
from vibium import browser

bro = browser.launch()
vibe = bro.new_page()
vibe.go("https://example.com")
print(vibe.title())                               # → 'Example Domain'
print(vibe.url())                                 # → 'https://example.com/'

# Semantic find with kwargs
link = vibe.find(role="link", text="More information")
link.click()

# State
h1 = vibe.find("h1")
print(h1.text())                                  # → text content

# Screenshot
png = vibe.screenshot()
assert len(png) > 1000

bro.close()
print("Phase 9 sync ✓")
```

#### Checkpoint (async):

```python
import asyncio
from vibium.async_api import browser

async def main():
    bro = await browser.launch()
    vibe = await bro.new_page()
    await vibe.go("https://example.com")
    print(await vibe.title())                     # → 'Example Domain'

    link = await vibe.find(role="link")
    await link.click()

    await bro.close()
    print("Phase 9 async ✓")

asyncio.run(main())
```

**Commands: 154 × 2 (sync + async)** | All Python targets complete.

---

### ⚠️ Human Review #4

Four of six targets shipping. Manually verify:

1. JS async — full checkpoint from Phase 7
2. JS sync — Phase 8 checkpoint
3. Python sync — Phase 9 sync checkpoint
4. Python async — Phase 9 async checkpoint
5. The same Go engine powers all four clients
6. Python `from vibium import browser` is sync (not async)

---

### Phase 10 — MCP Server + CLI + AI-Native Methods

#### Milestone 10.1: MCP server extension

The Go engine already has an MCP server. Extend it with the full API surface.

N/A for MCP (callback/event/low-level APIs):
`onDialog`, `onConsole`, `onRequest`, `onResponse`, `route`, `onWebSocket`, `onDownload`, `onFileChooser`, `onPage`, `onPopup`, `page.expose`, `mouse.down`, `mouse.up`, `mouse.move`, `keyboard.down`, `keyboard.up`

Everything else maps to an MCP tool (~120 commands).

#### Milestone 10.2: CLI for agents and scripting

```bash
vibium launch                                    # → returns session ID
vibium go https://example.com
vibium find --role button --text "Submit"
vibium click --role button --text "Submit"
vibium screenshot --output page.png
vibium check "the page loaded"
vibium close
```

- Same N/A rules as MCP for callback/event/low-level commands
- Output: JSON by default, `--human` for readable output
- Session management: `vibium launch` returns session ID, subsequent commands use it

#### Milestone 10.3: AI-Native methods (all 6 targets)

These are the reason Vibium exists. They sit on TOP of the deterministic API.

- `page.check(claim)` — Screenshot → multimodal LLM → structured response
- `page.check(claim, {near})` — Scoped screenshot + DOM snapshot → LLM
- `page.do(action)` — Screenshot + DOM → LLM plans → executes via find/click/fill
- `page.do(action, {data})` — Same with structured data for form fills

The key insight: `page.do()` uses Vibium's own deterministic API under the hood. It's AI planning, not AI puppeteering.

#### Checkpoint (MCP):

```bash
# Start MCP server
vibium --mcp

# Send JSON-RPC tool calls and verify responses for:
# browser_launch, browser_navigate, browser_find, browser_click, browser_screenshot
```

#### Checkpoint (CLI):

```bash
vibium launch
vibium go https://example.com
vibium find --css "h1"                            # → JSON with element info
vibium screenshot --output /tmp/test.png
test -f /tmp/test.png && echo "screenshot exists"
vibium close
echo "Phase 10 CLI ✓"
```

#### Checkpoint (AI-native):

```javascript
const bro = await browser.launch()
const vibe = await bro.newPage()
await vibe.go('https://example.com')

const result = await vibe.check('the page has a heading')
console.log(result.passed)                        // → true

await vibe.do('click the "More information" link')
console.log(await vibe.url())                     // → iana.org URL

await bro.close()
console.log('Phase 10 ✓')
```

**All 6 targets complete. AI-native methods live.**

---

### ⚠️ Human Review #5 — Final

All 6 implementation targets shipping. Run the full verification:

1. **JS async** — Run Phase 7 checkpoint end-to-end
2. **JS sync** — Run Phase 8 checkpoint
3. **Python sync** — Run Phase 9 sync checkpoint
4. **Python async** — Run Phase 9 async checkpoint
5. **MCP** — Launch MCP server, send tool calls, verify responses
6. **CLI** — Run Phase 10 CLI checkpoint
7. **AI-native** — `page.check()` and `page.do()` work in at least JS + Python
8. **areweplaywrightyet.md** — Update tracker statuses to reflect actual implementation

---

## Summary

| Phase | Focus | New cmds | Total | Milestone |
|-----|-------|----------|-------|-----------|
| 1 | Navigation + Pages/Contexts | 20 | 20 | Engine nav + JS async wiring |
| 2 | Element Finding + Chaining | 24 | 44 | Dual-signature find() |
| 3 | Element Interaction | 16 | 60 | Auto-wait click/fill/type |
| — | ⚠️ Human Review #1 | — | — | Core automation loop works |
| 4 | Element State + Waiting | 19 | 79 | State queries + wait primitives |
| 5 | Keyboard/Mouse + Screenshots + Eval | 19 | 98 | Input + capture + eval |
| — | ⚠️ Human Review #2 | — | — | Tier 1 + Tier 2 complete |
| 6 | Network + Dialogs | 26 | 124 | BiDi network interception |
| 7 | Cookies + Frames + Emulation + Rest | 30 | 154 | Full engine complete |
| — | ⚠️ Human Review #3 | — | — | All 154 commands in engine + JS async |
| 8 | JS sync wrapper | — | 154 | JS sync mirrors async |
| 9 | Python sync + async | — | 154 | Both Python clients ship |
| — | ⚠️ Human Review #4 | — | — | 4 of 6 targets verified |
| 10 | MCP + CLI + AI-Native | +4 | 158 | All 6 targets + AI methods |
| — | ⚠️ Human Review #5 | — | — | Everything ships |

---

## Post-Sprint (not in this plan)

- Remove `Vibe` class (`vibe.ts`) — legacy flat API superseded by `Browser → Page` object model. Move `FindOptions` to `page.ts`, update sync imports, drop export.
- Browser launch options (headless, channel, args, slow motion)
- `browser.connect(wsEndpoint)` for remote browsers
- Multi-browser selection (Firefox, WebKit)
- Part 2 language bindings (Java, C#, Ruby, Kotlin, Nim)
- `@vibium/hope` assertion library
- DX features (codegen, trace viewer, VS Code extension, test runner)
- Video recording, HAR recording/replay
- areweplaywrightyet.com deployment
