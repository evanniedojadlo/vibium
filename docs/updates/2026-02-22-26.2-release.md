# vibium 26.2

v1 shipped in december. since then: 145 commits, a ton of bug fixes, and a completely new feature set. this is the biggest update since launch.

the headline: **167 commands across 23 categories, shipped across 6 implementation targets** — JS async, JS sync, Python async, Python sync, MCP, and CLI. every target is at parity. the same API surface everywhere.

here's what's new.

---

## tracing

record everything your automation does and replay it in a visual timeline. compatible with the [Playwright trace viewer](https://trace.playwright.dev).

```javascript
const ctx = await bro.newContext()
const vibe = await ctx.page()

await ctx.tracing.start({ screenshots: true, snapshots: true })
await vibe.go('https://example.com')
await vibe.find('a').click()
const zip = await ctx.tracing.stop({ path: 'trace.zip' })
```

open `trace.zip` in [trace.vibium.dev](https://trace.vibium.dev) or [trace.playwright.dev](https://trace.playwright.dev) — you get a full timeline with screenshots, DOM snapshots, network waterfall, and action markers.

**action groups** let you label sections of your trace:

```javascript
await ctx.tracing.startGroup('login flow')
await vibe.find('#user').fill('admin')
await vibe.find('#pass').fill('secret')
await vibe.find('button').click()
await ctx.tracing.stopGroup()
```

**chunks** split a long trace into segments without stopping:

```javascript
await ctx.tracing.start()
// ... do stuff ...
const chunk1 = await ctx.tracing.stopChunk()
await ctx.tracing.startChunk({ name: 'part-2' })
// ... do more stuff ...
const chunk2 = await ctx.tracing.stopChunk()
```

also available in Python:

```python
await ctx.tracing.start(screenshots=True, snapshots=True)
await vibe.go("https://example.com")
await ctx.tracing.stop(path="trace.zip")
```

---

## semantic find

find elements by what they *are*, not just their CSS selectors.

```javascript
await vibe.find({ role: 'button', text: 'Submit' }).click()
await vibe.find({ role: 'link', text: 'Sign up' }).click()
await vibe.find({ label: 'Email address' }).fill('me@example.com')
await vibe.find({ placeholder: 'Search...' }).type('vibium')
```

all find strategies: `role`, `text`, `label`, `placeholder`, `alt`, `title`, `testid`, `xpath`. combine them freely — `find({ role: 'button', text: 'Login' })` intersects both.

also works from the CLI:

```bash
vibium find --role button --text "Submit"
vibium find --role link --text "Sign up"
```

---

## network events & routing

intercept, mock, and observe network traffic.

```javascript
// mock an API
await vibe.route('**/api/users', route => {
  route.fulfill({ status: 200, body: JSON.stringify([{ name: 'test' }]) })
})

// observe requests
vibe.onRequest(req => console.log(req.method(), req.url()))
vibe.onResponse(resp => console.log(resp.status(), resp.url()))
```

network events also show up in traces — the network tab in the trace viewer shows every request with timing, headers, and status.

---

## capture

renamed from `waitFor` — clearer intent, more capabilities.

```javascript
// wait for navigation to complete
const response = await vibe.capture.navigation(async () => {
  await vibe.find('a').click()
})

// wait for a download
const download = await vibe.capture.download(async () => {
  await vibe.find('#download-btn').click()
})

// wait for a dialog
const dialog = await vibe.capture.dialog(async () => {
  await vibe.eval('confirm("are you sure?")')
})
```

---

## cookies & storage

full cookie management via browser contexts.

```javascript
const ctx = await bro.newContext()
const vibe = await ctx.page()

await ctx.setCookies([{ name: 'token', value: 'abc123', url: 'https://example.com' }])
const cookies = await ctx.cookies()
await ctx.clearCookies()
```

---

## clock control

freeze, fast-forward, and manipulate time in the browser.

```javascript
await vibe.clock.install()
await vibe.clock.setFixedTime(new Date('2026-06-15T09:30:00'))

const time = await vibe.eval('new Date().toLocaleTimeString()')
// → "9:30:00 AM"

await vibe.clock.fastForward(30000) // advance 30 seconds

const updated = await vibe.eval('new Date().toLocaleTimeString()')
// → "9:30:30 AM"

await vibe.clock.setTimezone('Asia/Tokyo') // full list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
```

---

## accessibility

query the accessibility tree and element roles.

```javascript
const tree = await vibe.a11yTree()
// → { role: "main", children: [
//     { role: "heading", name: "Welcome back", level: 1 },
//     { role: "textbox", name: "Email address", required: true },
//     { role: "textbox", name: "Password", required: true },
//     { role: "button", name: "Sign in" },
//     { role: "link", name: "Forgot password?" }
//   ]}
```

---

## window & viewport

control the browser window and page viewport.

```javascript
const win = await vibe.window()
// → { x: 0, y: 0, width: 1280, height: 720, state: 'normal' }

await vibe.setWindow({ width: 375, height: 812 })  // mobile size
await vibe.setWindow({ state: 'maximized' })

// viewport controls the page rendering size independently of the window
await vibe.setViewport({ width: 375, height: 812 })
const vp = await vibe.viewport()
// → { width: 375, height: 812 }
```

---

## console & errors

capture browser console output and JavaScript errors.

```javascript
vibe.onConsole(msg => console.log(msg.text()))
vibe.onError(err => console.log(err.message))

// or collect them all at once
const messages = await vibe.consoleMessages()
const errors = await vibe.errors()
```

---

## full API parity

167 commands. 6 targets. all at parity.

the same operation works the same way in JS async, JS sync, Python async, Python sync, MCP, and CLI. this isn't "we have bindings for other languages" — this is identical API surface everywhere, with consistent naming conventions (`camelCase` in JS, `snake_case` in Python).

here's the surface area by class:

| Class | Methods | Description |
|-------|---------|-------------|
| **Browser** | 8 | launch, close, page management, event listeners |
| **Page** | 70+ | navigation, finding, evaluation, network, emulation, events, screenshots |
| **Element** | 36 | click, fill, type, state queries, attributes, drag, scroll |
| **ElementList** | 6 | count, first, last, nth, filter |
| **BrowserContext** | 8 | pages, cookies, storage, init scripts, tracing |
| **Keyboard** | 4 | press, down, up, type |
| **Mouse** | 5 | click, move, down, up, wheel |
| **Touch** | 1 | tap |
| **Clock** | 8 | install, fast-forward, pause, resume, set time, timezone |
| **Tracing** | 6 | start, stop, chunks, groups |
| **Capture** | 6 | response, request, navigation, download, dialog, event |

the same code in all four client flavors:

```javascript
// JS async
const bro = await browser.launch()
const vibe = await bro.page()
await vibe.go('https://example.com')
await vibe.find({ role: 'button', text: 'Submit' }).click()
await bro.close()
```

```javascript
// JS sync
import { browser } from 'vibium/sync'
const bro = browser.launch()
const vibe = bro.page()
vibe.go('https://example.com')
vibe.find({ role: 'button', text: 'Submit' }).click()
bro.close()
```

```python
# Python async
bro = await browser.launch()
vibe = await bro.page()
await vibe.go("https://example.com")
await vibe.find(role="button", text="Submit").click()
await bro.close()
```

```python
# Python sync
from vibium import browser_sync
bro = browser_sync.launch()
vibe = bro.page()
vibe.go("https://example.com")
vibe.find(role="button", text="Submit").click()
bro.close()
```

sync APIs are first-class — same method count, same capabilities. network events, tracing, cookies, dialogs, console — all available in both sync and async, in both JS and Python.

---

## CLI

82 commands across 18 categories. not a debugging tool — a full automation interface.

**navigation** — `go`, `back`, `forward`, `reload`, `url`, `title`

**discovery** — `map`, `diff-map`, `find`, `find-all`, `a11y-tree`

**interaction** — `click`, `dblclick`, `hover`, `fill`, `type`, `press`, `keys`, `select`, `check`, `uncheck`, `focus`, `drag`, `upload`, `scroll`, `scroll-into-view`, `highlight`

**mouse** — `mouse-click`, `mouse-move`, `mouse-down`, `mouse-up`

**element state** — `text`, `html`, `value`, `attr`, `is-visible`, `is-enabled`, `is-checked`, `count`

**waiting** — `wait`, `wait-for-url`, `wait-for-load`, `wait-for-text`, `wait-for-fn`, `sleep`

**screenshots & pdf** — `screenshot`, `pdf`

**dialogs** — `dialog-accept`, `dialog-dismiss`

**cookies & storage** — `cookies`, `set-cookie`, `delete-cookies`, `storage-state`, `restore-storage`

**tabs** — `tab-new`, `tabs`, `tab-switch`, `tab-close`

**frames** — `frame`, `frames`

**emulation** — `viewport`, `set-viewport`, `window`, `set-window`, `emulate-media`, `set-geolocation`, `set-content`

**evaluation** — `eval`

**tracing** — `trace-start`, `trace-stop`

**downloads** — `download`

**browser lifecycle** — `quit`

**infrastructure** — `daemon`, `serve`, `mcp`, `paths`, `add-skill`, `version`

### the ref-based workflow

the CLI assigns `@ref` identifiers to interactive elements. this is the core workflow:

```bash
vibium go https://example.com       # navigate
vibium map                           # discover elements → @e1, @e2, @e3...
vibium click @e3                     # interact by ref
vibium fill @e5 "hello world"        # fill by ref
vibium map                           # re-map after DOM changes
```

`map` returns a structured list of interactive elements with their types, text, and refs. `diff-map` shows what changed since the last map. this is how AI agents navigate pages without CSS selectors.

### semantic find from CLI

every find strategy works from the command line:

```bash
vibium find --text "Submit"
# → @e1 [button] "Submit"

vibium click @e1
# use the returned @ref to interact with the found element

vibium find --role button
vibium find --label "Email address"
vibium find --placeholder "Search..."
vibium find --alt "Logo"
vibium find --title "Close"
vibium find --testid "login-form"
vibium find --xpath "//div[@class='main']"
```

### chaining

```bash
vibium go https://example.com && vibium map
vibium click @e3 && vibium screenshot
vibium fill @e5 "admin" && vibium fill @e6 "secret" && vibium click @e7
```

### scoped mapping

```bash
vibium map                       # full page
vibium map --selector "nav"      # just the navigation
vibium map --selector "form"     # just the form
```

---

## agent skills

`vibium add-skill` installs a Claude Code skill that teaches the agent the ref-based browser workflow. once installed, Claude knows how to:

1. **navigate** — `vibium go <url>`
2. **map** — `vibium map` to discover elements and their `@ref` identifiers
3. **interact** — use refs to click, fill, select, type
4. **re-map** — `vibium map` again after navigation or DOM changes

the skill includes the full CLI reference (83 commands), common patterns (form filling, authentication, data extraction, multi-tab workflows), and debugging strategies.

```bash
vibium add-skill     # install to ~/.claude/skills/vibe-check/
```

after installation, Claude Code automatically picks up the skill and can automate browsers without any additional prompting.

---

## MCP server

82 MCP tools. works with Claude Desktop, Cursor, and any MCP-compatible client.

```bash
vibium mcp    # start the MCP server over stdio
```

the MCP server exposes the same capabilities as the CLI — navigation, element interaction, screenshots, cookies, tracing — all over the standard MCP protocol.

key tools for AI agents:

- `browser_map` / `browser_diff_map` — discover and track interactive elements
- `browser_find` — semantic element finding (by role, text, label, etc.)
- `browser_a11y_tree` — full accessibility tree
- `browser_screenshot` — visual page state
- `browser_navigate`, `browser_click`, `browser_fill`, `browser_type` — standard interaction
- `page_clock_*` — 8 tools for time manipulation

73 `browser_*` tools + 8 `page_clock_*` tools. the full list maps 1:1 to the CLI commands.

---

## bug fixes

- fixed browser left open on Ctrl+C — process exit handlers now clean up properly
- fixed Windows zombie Chrome/chromedriver processes (#78)
- fixed Chrome temp profile directory leak on close
- cleaned up orphaned Chrome for Testing temp directories
- fixed WebSocket frame size limit (now 10MB)
- fixed sync API process hang and route handler callback failures
- fixed Python sync API: removed misleading route post_data, added error handling to event callbacks
- fixed Python websockets deprecation warnings
- fixed Python platform packages not including clicker binaries
- fixed BiDi error response parsing to follow WebDriver BiDi spec
- fixed MCP server compatibility with Claude Desktop (#42)
- fixed CLI arguments not being forwarded to clicker binary
- fixed npm install failing due to missing version in root package.json
- fixed Makefile for GnuWin32 Make 3.81 on Windows
- disabled Chrome password manager and leak detection prompts
- suppressed macOS notification permission dialog on Chrome launch
- required Chrome for Testing, removed unreliable system Chrome fallback

---

## what's next

working on network interception improvements, video recording, and more AI-native features (`page.do()`, `page.check()`). see the [V2 roadmap](../reference/V2-ROADMAP.md) for the full picture.

---

*february 22, 2026*
