# Vibium 26.2

V1 shipped in December. Since then: 200+ commits, a ton of bug fixes, and a completely new feature set. This is the biggest update since launch.

The headline: **161 commands across 22 categories, shipped across 6 implementation targets** â€” JS async, JS sync, Python async, Python sync, MCP, and CLI. Every target is near-complete parity. The same API surface everywhere.

Here's what's new.

---

## CalVer

Vibium now uses calendar versioning. `26.2` = February 2026. No more semver â€” just the date it shipped. It's been a long run getting to this point. ðŸ˜

---

## Tracing

Record everything your automation does and replay it in a visual timeline. View in the [Vibium trace viewer](https://trace.vibium.dev).

```javascript
const ctx = await bro.newContext()
const vibe = await ctx.page()

await ctx.tracing.start({ screenshots: true, snapshots: true })
await vibe.go('https://example.com')
await vibe.find('a').click()
const zip = await ctx.tracing.stop({ path: 'trace.zip' })
```

Open `trace.zip` in [trace.vibium.dev](https://trace.vibium.dev) or [trace.playwright.dev](https://trace.playwright.dev) â€” you get a full timeline with screenshots, DOM snapshots, network waterfall, and action markers.

**Action groups** let you label sections of your trace:

```javascript
await ctx.tracing.startGroup('login flow')
await vibe.find('#user').fill('admin')
await vibe.find('#pass').fill('secret')
await vibe.find('button').click()
await ctx.tracing.stopGroup()
```

**Chunks** split a long trace into segments without stopping:

```javascript
await ctx.tracing.start()
// ... do stuff ...
const chunk1 = await ctx.tracing.stopChunk()
await ctx.tracing.startChunk({ name: 'part-2' })
// ... do more stuff ...
const chunk2 = await ctx.tracing.stopChunk()
```

Also available in Python:

```python
await ctx.tracing.start(screenshots=True, snapshots=True)
await vibe.go("https://example.com")
await ctx.tracing.stop(path="trace.zip")
```

---

## Semantic Find

Find elements by what they *are*, not just their CSS selectors.

```javascript
await vibe.find({ role: 'button', text: 'Submit' }).click()
await vibe.find({ role: 'link', text: 'Sign up' }).click()
await vibe.find({ label: 'Email address' }).fill('me@example.com')
await vibe.find({ placeholder: 'Search...' }).type('vibium')
```

All find strategies: `role`, `text`, `label`, `placeholder`, `alt`, `title`, `testid`, `xpath`. Combine them freely â€” `find({ role: 'button', text: 'Login' })` intersects both.

Also works from the CLI:

```bash
vibium find --role button --text "Submit"
vibium find --role link --text "Sign up"
```

---

## Network Events & Routing

Intercept, mock, and observe network traffic.

```javascript
// mock an API
await vibe.route('**/api/users', route => {
  route.fulfill({ status: 200, body: JSON.stringify([{ name: 'test' }]) })
})

// observe requests
vibe.onRequest(req => console.log(req.method(), req.url()))
vibe.onResponse(resp => console.log(resp.status(), resp.url()))
```

Network events also show up in traces â€” the network tab in the trace viewer shows every request with timing, headers, and status.

---

## Capture

Set up a listener before the action, get the result after.

```javascript
// wait for navigation to complete
const response = await vibe.capture.navigation(async () => {
  await vibe.find('a').click()
})

// wait for a download
const download = await vibe.capture.download(async () => {
  await vibe.find('#download-btn').click()
})

// wait for a dialog
const dialog = await vibe.capture.dialog(async () => {
  await vibe.evaluate('confirm("are you sure?")')
})
```

---

## Cookies & Storage

Full cookie management via browser contexts.

```javascript
const ctx = await bro.newContext()
const vibe = await ctx.page()

await ctx.setCookies([{ name: 'token', value: 'abc123', url: 'https://example.com' }])
const cookies = await ctx.cookies()
await ctx.clearCookies()
```

---

## Clock Control

Freeze, fast-forward, and manipulate time in the browser.

```javascript
await vibe.clock.install()
await vibe.clock.setFixedTime(new Date('2026-06-15T09:30:00'))

const time = await vibe.evaluate('new Date().toLocaleTimeString()')
// â†’ "9:30:00 AM"

await vibe.clock.fastForward(30000) // advance 30 seconds

const updated = await vibe.evaluate('new Date().toLocaleTimeString()')
// â†’ "9:30:30 AM"

await vibe.clock.setTimezone('Asia/Tokyo') // full list: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
```

---

## Accessibility

Query the accessibility tree and element roles.

```javascript
const tree = await vibe.a11yTree()
// â†’ { role: "main", children: [
//     { role: "heading", name: "Welcome back", level: 1 },
//     { role: "textbox", name: "Email address", required: true },
//     { role: "textbox", name: "Password", required: true },
//     { role: "button", name: "Sign in" },
//     { role: "link", name: "Forgot password?" }
//   ]}
```

---

## Window & Viewport

Control the browser window and page viewport.

```javascript
const win = await vibe.window()
// â†’ { x: 0, y: 0, width: 1280, height: 720, state: 'normal' }

await vibe.setWindow({ width: 375, height: 812 })  // mobile size
await vibe.setWindow({ state: 'maximized' })

// viewport controls the page rendering size independently of the window
await vibe.setViewport({ width: 375, height: 812 })
const vp = await vibe.viewport()
// â†’ { width: 375, height: 812 }
```

---

## Remote Browser

Connect to a browser running on another machine â€” cloud VMs, containers, test infrastructure.

```javascript
const bro = await browser.connect('ws://remote-host:9222')
const vibe = await bro.page()
await vibe.go('https://example.com')
```

```python
bro = await browser.connect("ws://remote-host:9222")
vibe = await bro.page()
await vibe.go("https://example.com")
```

Also works from the CLI:

```bash
vibium daemon start --connect ws://remote-host:9222
vibium go https://example.com
```

Under the hood, the local transport layer from client libs to Vibium's internal clicker engine binary was rewritten from WebSocket to stdin/stdout pipes, which makes local connections faster and more reliable while keeping WebSocket available for remote connections.

---

## Actionability

Interactions now wait for elements to be ready before acting â€” matching Playwright's actionability model. `click()` waits for the element to be visible, stable (not animating), able to receive events, and enabled. `fill()` and `type()` additionally wait for the element to be editable.

No configuration needed. If an element isn't ready within the timeout, you get a clear error explaining what check failed.

---

## Console & Errors

Capture browser console output and JavaScript errors.

```javascript
vibe.onConsole(msg => console.log(msg.text()))
vibe.onError(err => console.log(err.message))

// or collect them all at once
const messages = vibe.consoleMessages()
const errors = vibe.errors()
```

---

## Full API Parity

161 commands. 6 targets. All at near-parity.

The same operation works the same way in JS async, JS sync, Python async, Python sync, MCP, and CLI. Identical API surface everywhere, with consistent naming conventions (`camelCase` in JS, `snake_case` in Python).

Here's the surface area by class:

| Class | Methods | Description |
|-------|---------|-------------|
| **Browser** | 9 | launch, connect, close, page management, event listeners |
| **Page** | 70+ | navigation, finding, evaluation, network, emulation, events, screenshots |
| **Element** | 36 | click, fill, type, state queries, attributes, drag, scroll |
| **BrowserContext** | 8 | pages, cookies, storage, init scripts, tracing |
| **Keyboard** | 4 | press, down, up, type |
| **Mouse** | 5 | click, move, down, up, wheel |
| **Touch** | 1 | tap |
| **Clock** | 8 | install, fast-forward, pause, resume, set time, timezone |
| **Tracing** | 6 | start, stop, chunks, groups |
| **Capture** | 6 | response, request, navigation, download, dialog, event |

The same code in all four client flavors:

```javascript
// JS async
const bro = await browser.launch()
const vibe = await bro.page()
await vibe.go('https://example.com')
await vibe.find({ role: 'button', text: 'Submit' }).click()
await bro.close()
```

```javascript
// JS sync
import { browser } from 'vibium/sync'
const bro = browser.launch()
const vibe = bro.page()
vibe.go('https://example.com')
vibe.find({ role: 'button', text: 'Submit' }).click()
bro.close()
```

```python
# Python async
bro = await browser.launch()
vibe = await bro.page()
await vibe.go("https://example.com")
await vibe.find(role="button", text="Submit").click()
await bro.close()
```

```python
# Python sync
from vibium import browser
bro = browser.launch()
vibe = bro.page()
vibe.go("https://example.com")
vibe.find(role="button", text="Submit").click()
bro.close()
```

Sync APIs are first-class â€” same method count, same capabilities. Network events, tracing, cookies, dialogs, console â€” all available in both sync and async, in both JS and Python.

---

## CLI

82 commands across 17 categories. Not a debugging tool â€” a full automation interface for agents (or humans).

**Navigation** â€” `go`, `back`, `forward`, `reload`, `url`, `title`

**Discovery** â€” `map`, `diff-map`, `find`, `find-all`, `a11y-tree`

**Interaction** â€” `click`, `dblclick`, `hover`, `fill`, `type`, `press`, `keys`, `select`, `check`, `uncheck`, `focus`, `drag`, `upload`, `scroll`, `scroll-into-view`, `highlight`

**Mouse** â€” `mouse-click`, `mouse-move`, `mouse-down`, `mouse-up`

**Element state** â€” `text`, `html`, `value`, `attr`, `is-visible`, `is-enabled`, `is-checked`, `count`

**Waiting** â€” `wait`, `wait-for-url`, `wait-for-load`, `wait-for-text`, `wait-for-fn`, `sleep`

**Screenshots & PDF** â€” `screenshot`, `pdf`

**Dialogs** â€” `dialog-accept`, `dialog-dismiss`

**Cookies & storage** â€” `cookies`, `set-cookie`, `delete-cookies`, `storage-state`, `restore-storage`

**Tabs** â€” `tab-new`, `tabs`, `tab-switch`, `tab-close`

**Frames** â€” `frame`, `frames`

**Emulation** â€” `viewport`, `set-viewport`, `window`, `set-window`, `emulate-media`, `set-geolocation`, `set-content`

**Evaluation** â€” `evaluate`

**Tracing** â€” `trace-start`, `trace-stop`

**Downloads** â€” `download`

**Browser lifecycle** â€” `connect`, `quit`

**Infrastructure** â€” `daemon`, `serve`, `mcp`, `paths`, `add-skill`, `version`

### The Ref-Based Workflow

The CLI assigns `@ref` identifiers to interactive elements. This is the core workflow:

```bash
vibium go https://example.com       # navigate
vibium map                           # discover elements â†’ @e1, @e2, @e3...
vibium click @e3                     # interact by ref
vibium fill @e5 "hello world"        # fill by ref
vibium map                           # re-map after DOM changes
```

`map` returns a structured list of interactive elements with their types, text, and refs. `diff-map` shows what changed since the last map. This is how AI agents navigate pages without CSS selectors.

### Semantic Find from CLI

Every find strategy works from the command line:

```bash
vibium find --text "Submit"
# â†’ @e1 [button] "Submit"

vibium click @e1
# use the returned @ref to interact with the found element

vibium find --role button
vibium find --label "Email address"
vibium find --placeholder "Search..."
vibium find --alt "Logo"
vibium find --title "Close"
vibium find --testid "login-form"
vibium find --xpath "//div[@class='main']"
```

### Chaining

```bash
vibium go https://example.com && vibium map
vibium click @e3 && vibium screenshot
vibium fill @e5 "admin" && vibium fill @e6 "secret" && vibium click @e7
```

### Scoped Mapping

```bash
vibium map                       # full page
vibium map --selector "nav"      # just the navigation
vibium map --selector "form"     # just the form
```

---

## Agent Skills

`vibium add-skill` installs a Claude Code skill that teaches the agent the ref-based browser workflow. Once installed, Claude knows how to:

1. **navigate** â€” `vibium go <url>`
2. **map** â€” `vibium map` to discover elements and their `@ref` identifiers
3. **interact** â€” use refs to click, fill, select, type
4. **re-map** â€” `vibium map` again after navigation or DOM changes

The skill includes the full CLI reference (82 commands), common patterns (form filling, authentication, data extraction, multi-tab workflows), and debugging strategies.

```bash
vibium add-skill     # install to ~/.claude/skills/vibe-check/
```

After installation, Claude Code automatically picks up the skill and can automate browsers without any additional prompting.

---

## MCP Server

81 MCP tools. Works with Claude Desktop, Cursor, and any MCP-compatible client.

```bash
vibium mcp    # start the MCP server over stdio
```

The MCP server exposes the same capabilities as the CLI â€” navigation, element interaction, screenshots, cookies, tracing â€” all over the standard MCP protocol.

Key tools for AI agents:

- `browser_map` / `browser_diff_map` â€” discover and track interactive elements
- `browser_find` â€” semantic element finding (by role, text, label, etc.)
- `browser_a11y_tree` â€” full accessibility tree
- `browser_screenshot` â€” visual page state
- `browser_navigate`, `browser_click`, `browser_fill`, `browser_type` â€” standard interaction
- `page_clock_*` â€” 8 tools for time manipulation

73 `browser_*` tools + 8 `page_clock_*` tools. The full list maps 1:1 to the CLI commands.

---

## Bug Fixes

- Fixed dialog button clicks silently passing without actually clicking (#36)
- Fixed macOS Gatekeeper blocking chromedriver â€” quarantine attribute now removed after download (#33)
- Fixed browser left open on Ctrl+C â€” process exit handlers now clean up properly
- Fixed Windows zombie Chrome/chromedriver processes (#78)
- Fixed Chrome process leak on browser close
- Fixed browser process surviving Python REPL exit
- Fixed fork bomb when Python client finds its own CLI wrapper via `shutil.which`
- Fixed Chrome temp profile directory leak on close
- Cleaned up orphaned Chrome for Testing temp directories
- Fixed WebSocket frame size limit (now 10MB)
- Added WebSocket ping keep-alive to prevent idle connection timeouts
- Fixed connection race conditions, zombie processes, and test suite hangs
- Fixed event handler leak on page close
- Fixed timer leak in Download completion handler
- Fixed sync API process hang and route handler callback failures
- Fixed Python sync timeout detection, event loop, and error handling
- Fixed Python websockets deprecation warnings
- Fixed Python platform packages not including vibium binaries
- Fixed BiDi error response parsing to follow WebDriver BiDi spec
- Fixed MCP server compatibility with Claude Desktop (#42)
- Fixed CLI arguments not being forwarded to clicker binary
- Fixed npm install failing due to missing version in root package.json
- Fixed pipe stdio on Windows with platform-specific fd duplication
- Fixed Chrome sandbox permission errors on Windows
- Fixed Makefile for GnuWin32 Make 3.81 on Windows
- Disabled Chrome password manager and leak detection prompts
- Suppressed macOS notification permission dialog on Chrome launch
- Required Chrome for Testing, removed unreliable system Chrome fallback
- Added timeouts to all hang-prone code paths across Go, JS, and Python

---

## What's Next

On the roadmap: more network and cloud browser support, more browser, video recording, AI-powered locators (`page.do()`, `page.check()`), and Java/.NET clients. See the [roadmap](../../ROADMAP.md) for the full picture â€” we're building what users ask for.

---

*February 28, 2026*
